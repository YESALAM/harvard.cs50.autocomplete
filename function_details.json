[{"library_name": "cs50.h", "fun_name": "get_char", "signature": "char get_char(string prompt);", "description": "`get_char` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_char` returns the `char` read on success; if the user input is not a `char`, the user is prompted to retry (until a `char` is inputted or the user cancels). If the line cannot be read at all, `CHAR_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_double", "signature": "double get_double(string prompt);", "description": "`get_double` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note that a `double` is, like `float`, a floating-point real number. However, the `double` type is twice as big as the `float` type, allowing it to be more precise. Generally speaking, `double` is preferable to `float` on modern computers, where memory is generally not sparse.", "return_value": "`get_double` returns the `double` read on success; if the user input is not readable as a `double`, the user is prompted to retry (until a `double` is inputted or the user cancels). If the line cannot be read at all, `DBL_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_float", "signature": "float get_float(string prompt);", "description": "`get_float` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_float` returns the `float` read on success; if the user input is not readable as a `float`, the user is prompted to retry (until a `float` is inputted or the user cancels). If the line cannot be read at all, `FLT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_int", "signature": "int get_int(string prompt);", "description": "`get_int` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_int` returns the `int` read on success; if the user input is not an `int`, the user is prompted to retry (until an `int` is inputted or the user cancels). If the line cannot be read at all, `INT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_long_long` take `long long` input from the user", "signature": "long long get_long_long(string prompt);", "description": "`get_long_long` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note: `long long` is the same type as `long long int`: the `int` at the end is optional. A `long long` is still an integer, but the `long long` type can store larger numbers than just an `int`.", "return_value": "`get_long_long` returns the `long long` read on success; if the user input is not a `long long`, the user is prompted to retry (until a `long long` is inputted or the user cancels). If the line cannot be read at all, `LLONG_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_string", "signature": "string get_string(string prompt);", "description": "`get_string` prints a prompt to the user and reads from `stdin`.", "return_value": "`get_string` returns the `string` read on success; if the user input is not readable as a `string`, the user is prompted to retry (until a `string` is inputted or the user cancels). If the line cannot be read at all, `NULL` is returned, representing an error."},{"library_name": "cs50.h", "fun_name": "get_char", "signature": "char get_char(string prompt);", "description": "`get_char` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_char` returns the `char` read on success; if the user input is not a `char`, the user is prompted to retry (until a `char` is inputted or the user cancels). If the line cannot be read at all, `CHAR_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_double", "signature": "double get_double(string prompt);", "description": "`get_double` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note that a `double` is, like `float`, a floating-point real number. However, the `double` type is twice as big as the `float` type, allowing it to be more precise. Generally speaking, `double` is preferable to `float` on modern computers, where memory is generally not sparse.", "return_value": "`get_double` returns the `double` read on success; if the user input is not readable as a `double`, the user is prompted to retry (until a `double` is inputted or the user cancels). If the line cannot be read at all, `DBL_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_float", "signature": "float get_float(string prompt);", "description": "`get_float` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_float` returns the `float` read on success; if the user input is not readable as a `float`, the user is prompted to retry (until a `float` is inputted or the user cancels). If the line cannot be read at all, `FLT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_int", "signature": "int get_int(string prompt);", "description": "`get_int` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_int` returns the `int` read on success; if the user input is not an `int`, the user is prompted to retry (until an `int` is inputted or the user cancels). If the line cannot be read at all, `INT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_long_long` take `long long` input from the user", "signature": "long long get_long_long(string prompt);", "description": "`get_long_long` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note: `long long` is the same type as `long long int`: the `int` at the end is optional. A `long long` is still an integer, but the `long long` type can store larger numbers than just an `int`.", "return_value": "`get_long_long` returns the `long long` read on success; if the user input is not a `long long`, the user is prompted to retry (until a `long long` is inputted or the user cancels). If the line cannot be read at all, `LLONG_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_string", "signature": "string get_string(string prompt);", "description": "`get_string` prints a prompt to the user and reads from `stdin`.", "return_value": "`get_string` returns the `string` read on success; if the user input is not readable as a `string`, the user is prompted to retry (until a `string` is inputted or the user cancels). If the line cannot be read at all, `NULL` is returned, representing an error."}, {"library_name": "ctype.h"}, {"library_name": "ctype.h", "fun_name": "isalnum", "signature": "int isalnum(int c);", "description": "`isalnum` takes a `char` as input and computes whether the character is alphanumeric.", "return_value": "`isalnum` returns a nonzero integer if it is either numeric or alphabetic (e.g. '1' or 'D') and zero if it is neither (e.g. '['). Note that C treats 0 as false and 1 as true; as such, `isalnum` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isalpha", "signature": "int isalpha(int c);", "description": "`isalpha` takes a character as input and computes whether the character is alphabetic.", "return_value": "`isalpha` returns a nonzero integer if it is alphabetic (e.g. 'C' or 'S') and zero if it is neither (e.g. '>' or '4'). Note that C treats 0 as false and 1 as true; as such, `isalpha` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isblank", "signature": "int isblank(int c);", "description": "`isblank` takes a character as input and calculates whether it is a blank character (space, tab).", "return_value": "`isblank` returns a nonzero integer if it is blank (e.g. ' ' or '  ', that is, space or tab) and zero if it is neither (e.g. 'y' or '}'). Note that C treats 0 as false and 1 as true; as such, `isblank` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isdigit", "signature": "int isdigit(int c);", "description": "`isdigit` takes a character as input and calculates whether it is a digit. N.B.: Since `isdigit` only covers decimal digits, don't use it for hexadecimal digits, such as `A` or `F`!", "return_value": "`isdigit` returns a nonzero integer if it is a decimal digit and 0 if it is not. Note that C treats 0 as false and 1 as true; as such, `isdigit` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "tolower", "signature": "int tolower(int c);", "description": "`tolower` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`tolower` returns the lower case `char` corresponding to the input. However, if the input is not an upper case `char`, the input is simply returned as-is; e.g., `tolower` of `]` would return `]` This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "ctype.h", "fun_name": "toupper", "signature": "int toupper(int c);", "description": "`toupper` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`toupper` returns the corresponding upper case `char`. However, if the input is not an lower case `char`, the input is simply returned as-is; e.g., `toupper` of `~` would return `~`. This does not necessarily hold true outside the range of `unsigned char`."},{"library_name": "cs50.h", "fun_name": "get_char", "signature": "char get_char(string prompt);", "description": "`get_char` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_char` returns the `char` read on success; if the user input is not a `char`, the user is prompted to retry (until a `char` is inputted or the user cancels). If the line cannot be read at all, `CHAR_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_double", "signature": "double get_double(string prompt);", "description": "`get_double` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note that a `double` is, like `float`, a floating-point real number. However, the `double` type is twice as big as the `float` type, allowing it to be more precise. Generally speaking, `double` is preferable to `float` on modern computers, where memory is generally not sparse.", "return_value": "`get_double` returns the `double` read on success; if the user input is not readable as a `double`, the user is prompted to retry (until a `double` is inputted or the user cancels). If the line cannot be read at all, `DBL_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_float", "signature": "float get_float(string prompt);", "description": "`get_float` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_float` returns the `float` read on success; if the user input is not readable as a `float`, the user is prompted to retry (until a `float` is inputted or the user cancels). If the line cannot be read at all, `FLT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_int", "signature": "int get_int(string prompt);", "description": "`get_int` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_int` returns the `int` read on success; if the user input is not an `int`, the user is prompted to retry (until an `int` is inputted or the user cancels). If the line cannot be read at all, `INT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_long_long` take `long long` input from the user", "signature": "long long get_long_long(string prompt);", "description": "`get_long_long` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note: `long long` is the same type as `long long int`: the `int` at the end is optional. A `long long` is still an integer, but the `long long` type can store larger numbers than just an `int`.", "return_value": "`get_long_long` returns the `long long` read on success; if the user input is not a `long long`, the user is prompted to retry (until a `long long` is inputted or the user cancels). If the line cannot be read at all, `LLONG_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_string", "signature": "string get_string(string prompt);", "description": "`get_string` prints a prompt to the user and reads from `stdin`.", "return_value": "`get_string` returns the `string` read on success; if the user input is not readable as a `string`, the user is prompted to retry (until a `string` is inputted or the user cancels). If the line cannot be read at all, `NULL` is returned, representing an error."}, {"library_name": "ctype.h"}, {"library_name": "ctype.h", "fun_name": "isalnum", "signature": "int isalnum(int c);", "description": "`isalnum` takes a `char` as input and computes whether the character is alphanumeric.", "return_value": "`isalnum` returns a nonzero integer if it is either numeric or alphabetic (e.g. '1' or 'D') and zero if it is neither (e.g. '['). Note that C treats 0 as false and 1 as true; as such, `isalnum` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isalpha", "signature": "int isalpha(int c);", "description": "`isalpha` takes a character as input and computes whether the character is alphabetic.", "return_value": "`isalpha` returns a nonzero integer if it is alphabetic (e.g. 'C' or 'S') and zero if it is neither (e.g. '>' or '4'). Note that C treats 0 as false and 1 as true; as such, `isalpha` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isblank", "signature": "int isblank(int c);", "description": "`isblank` takes a character as input and calculates whether it is a blank character (space, tab).", "return_value": "`isblank` returns a nonzero integer if it is blank (e.g. ' ' or '  ', that is, space or tab) and zero if it is neither (e.g. 'y' or '}'). Note that C treats 0 as false and 1 as true; as such, `isblank` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isdigit", "signature": "int isdigit(int c);", "description": "`isdigit` takes a character as input and calculates whether it is a digit. N.B.: Since `isdigit` only covers decimal digits, don't use it for hexadecimal digits, such as `A` or `F`!", "return_value": "`isdigit` returns a nonzero integer if it is a decimal digit and 0 if it is not. Note that C treats 0 as false and 1 as true; as such, `isdigit` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "tolower", "signature": "int tolower(int c);", "description": "`tolower` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`tolower` returns the lower case `char` corresponding to the input. However, if the input is not an upper case `char`, the input is simply returned as-is; e.g., `tolower` of `]` would return `]` This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "ctype.h", "fun_name": "toupper", "signature": "int toupper(int c);", "description": "`toupper` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`toupper` returns the corresponding upper case `char`. However, if the input is not an lower case `char`, the input is simply returned as-is; e.g., `toupper` of `~` would return `~`. This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "stdio.h", "fun_name": "fclose", "signature": "int fclose(FILE *stream);", "description": "`fclose` is sort of the converse of [`fopen`](fopen.html). After you're done working with a file, `fclose` should be called on the associated stream to disconnect it from the file such that your file and its contents are saved safely. `fclose` takes only one parameter, a stream (of type `FILE *`). Generally, you should call `fclose` once for every call you make to `fopen`. Note too that once `fclose` is called on a stream, the stream now points to a garbage value; be careful about using streams which have already had `fclose` called on them.", "return_value": "`fclose` returns 0 on success. If an error of some sort occurs, `EOF` is returned."}, {"library_name": "stdio.h", "fun_name": "feof", "signature": "int feof(FILE *stream);", "description": "One part of the `FILE` type is the `EOF` flag. When a stream is positioned at the end of its associated file, this flag is set. As programmers, this is useful to know when we've reached the end of a file. `feof` takes only one parameter, a stream (of type `FILE *`) which is to be tested. `feof` allows testing whether the stream is positioned at its end without, say, attempting to read a character.", "return_value": "`feof` returns a non-zero `int` if `stream` is at `EOF`, otherwise 0."}, {"library_name": "stdio.h", "fun_name": "fopen", "signature": "FILE *fopen(const char *restrict filename, const char *restrict mode);", "description": "File I/O in C, just like other input and output, is done via streams. If you wish to write to and/or read from a file on the computer, you'll need to create a stream for that file: that's where `fopen` comes in. After the stream is opened, it can be interacted with (using other functions in `stdio`) as any other stream would be.", "return_value": "Upon success, `fopen` returns the stream associated with the provided `filename`. Otherwise, `NULL` is returned."}, {"library_name": "stdio.h", "fun_name": "fprintf", "signature": "int fprintf(FILE *restrict stream, const char *restrict format, ...);", "description": "`fprintf` is like `printf`, except it prints to a caller-specified stream instead of strictly `stdout`. In most cases for CS50, `fprintf` is used to print error messages to `stderr`. `fprintf` takes a stream as its first argument. Afterward, it takes the message along with any amount of format strings, just like `printf`.", "return_value": "`fprintf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h", "fun_name": "fread", "signature": "size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fread` reads in data from a stream into an array in memory. Unlike other methods of input, `fread` reads in blocks of data of a user-specified size, making it possible to read in, for instance, entire strings instead of just characters. That being said, since specific functions exist in `stdio.h` for reading in different C data types, generally `fread` is best used only when reading in custom data types.", "return_value": "`fread` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "fseek", "description": "C streams are designed to be worked with linearly: files are written to and read from one unit at a time. As such, by design, you can't merely access, say, the middle of a file immediately (what you may call \"random access\"). Instead, you'd have to \"seek forward\" from the beginning of the file to the middle. This is where `fseek` is useful. `fseek` allows you to reposition the so-called \"file position indicator\" in a stream. This allows you, effectively, to skip around to different parts of files.", "return_value": "`fseek` returns 0 upon success and -1 upon error."}, {"library_name": "stdio.h", "fun_name": "fwrite", "signature": "size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fwrite` writes data to a stream from an address in memory. Unlike other methods of output, `fwrite` writes blocks of data of a user-specified size, making it possible to write, for instance, entire `struct` blocks at once instead of each piece of a `struct` separately.", "return_value": "`fwrite` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "printf", "signature": "int printf(const char *restrict format, ...);", "description": "`printf` is, in CS50, the most common way of outputting messages to the user in C. You can use it to print most anything, from characters to strings, integers to double-precision floating point numbers, and pretty much everything in between. `printf` also allows you to add some limited formatting to the output; for example, you can print `float` values to any number of decimal places.", "return_value": "`printf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h"},{"library_name": "cs50.h", "fun_name": "get_char", "signature": "char get_char(string prompt);", "description": "`get_char` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_char` returns the `char` read on success; if the user input is not a `char`, the user is prompted to retry (until a `char` is inputted or the user cancels). If the line cannot be read at all, `CHAR_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_double", "signature": "double get_double(string prompt);", "description": "`get_double` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note that a `double` is, like `float`, a floating-point real number. However, the `double` type is twice as big as the `float` type, allowing it to be more precise. Generally speaking, `double` is preferable to `float` on modern computers, where memory is generally not sparse.", "return_value": "`get_double` returns the `double` read on success; if the user input is not readable as a `double`, the user is prompted to retry (until a `double` is inputted or the user cancels). If the line cannot be read at all, `DBL_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_float", "signature": "float get_float(string prompt);", "description": "`get_float` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_float` returns the `float` read on success; if the user input is not readable as a `float`, the user is prompted to retry (until a `float` is inputted or the user cancels). If the line cannot be read at all, `FLT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_int", "signature": "int get_int(string prompt);", "description": "`get_int` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_int` returns the `int` read on success; if the user input is not an `int`, the user is prompted to retry (until an `int` is inputted or the user cancels). If the line cannot be read at all, `INT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_long_long` take `long long` input from the user", "signature": "long long get_long_long(string prompt);", "description": "`get_long_long` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note: `long long` is the same type as `long long int`: the `int` at the end is optional. A `long long` is still an integer, but the `long long` type can store larger numbers than just an `int`.", "return_value": "`get_long_long` returns the `long long` read on success; if the user input is not a `long long`, the user is prompted to retry (until a `long long` is inputted or the user cancels). If the line cannot be read at all, `LLONG_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_string", "signature": "string get_string(string prompt);", "description": "`get_string` prints a prompt to the user and reads from `stdin`.", "return_value": "`get_string` returns the `string` read on success; if the user input is not readable as a `string`, the user is prompted to retry (until a `string` is inputted or the user cancels). If the line cannot be read at all, `NULL` is returned, representing an error."}, {"library_name": "ctype.h"}, {"library_name": "ctype.h", "fun_name": "isalnum", "signature": "int isalnum(int c);", "description": "`isalnum` takes a `char` as input and computes whether the character is alphanumeric.", "return_value": "`isalnum` returns a nonzero integer if it is either numeric or alphabetic (e.g. '1' or 'D') and zero if it is neither (e.g. '['). Note that C treats 0 as false and 1 as true; as such, `isalnum` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isalpha", "signature": "int isalpha(int c);", "description": "`isalpha` takes a character as input and computes whether the character is alphabetic.", "return_value": "`isalpha` returns a nonzero integer if it is alphabetic (e.g. 'C' or 'S') and zero if it is neither (e.g. '>' or '4'). Note that C treats 0 as false and 1 as true; as such, `isalpha` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isblank", "signature": "int isblank(int c);", "description": "`isblank` takes a character as input and calculates whether it is a blank character (space, tab).", "return_value": "`isblank` returns a nonzero integer if it is blank (e.g. ' ' or '  ', that is, space or tab) and zero if it is neither (e.g. 'y' or '}'). Note that C treats 0 as false and 1 as true; as such, `isblank` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isdigit", "signature": "int isdigit(int c);", "description": "`isdigit` takes a character as input and calculates whether it is a digit. N.B.: Since `isdigit` only covers decimal digits, don't use it for hexadecimal digits, such as `A` or `F`!", "return_value": "`isdigit` returns a nonzero integer if it is a decimal digit and 0 if it is not. Note that C treats 0 as false and 1 as true; as such, `isdigit` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "tolower", "signature": "int tolower(int c);", "description": "`tolower` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`tolower` returns the lower case `char` corresponding to the input. However, if the input is not an upper case `char`, the input is simply returned as-is; e.g., `tolower` of `]` would return `]` This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "ctype.h", "fun_name": "toupper", "signature": "int toupper(int c);", "description": "`toupper` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`toupper` returns the corresponding upper case `char`. However, if the input is not an lower case `char`, the input is simply returned as-is; e.g., `toupper` of `~` would return `~`. This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "stdio.h", "fun_name": "fclose", "signature": "int fclose(FILE *stream);", "description": "`fclose` is sort of the converse of [`fopen`](fopen.html). After you're done working with a file, `fclose` should be called on the associated stream to disconnect it from the file such that your file and its contents are saved safely. `fclose` takes only one parameter, a stream (of type `FILE *`). Generally, you should call `fclose` once for every call you make to `fopen`. Note too that once `fclose` is called on a stream, the stream now points to a garbage value; be careful about using streams which have already had `fclose` called on them.", "return_value": "`fclose` returns 0 on success. If an error of some sort occurs, `EOF` is returned."}, {"library_name": "stdio.h", "fun_name": "feof", "signature": "int feof(FILE *stream);", "description": "One part of the `FILE` type is the `EOF` flag. When a stream is positioned at the end of its associated file, this flag is set. As programmers, this is useful to know when we've reached the end of a file. `feof` takes only one parameter, a stream (of type `FILE *`) which is to be tested. `feof` allows testing whether the stream is positioned at its end without, say, attempting to read a character.", "return_value": "`feof` returns a non-zero `int` if `stream` is at `EOF`, otherwise 0."}, {"library_name": "stdio.h", "fun_name": "fopen", "signature": "FILE *fopen(const char *restrict filename, const char *restrict mode);", "description": "File I/O in C, just like other input and output, is done via streams. If you wish to write to and/or read from a file on the computer, you'll need to create a stream for that file: that's where `fopen` comes in. After the stream is opened, it can be interacted with (using other functions in `stdio`) as any other stream would be.", "return_value": "Upon success, `fopen` returns the stream associated with the provided `filename`. Otherwise, `NULL` is returned."}, {"library_name": "stdio.h", "fun_name": "fprintf", "signature": "int fprintf(FILE *restrict stream, const char *restrict format, ...);", "description": "`fprintf` is like `printf`, except it prints to a caller-specified stream instead of strictly `stdout`. In most cases for CS50, `fprintf` is used to print error messages to `stderr`. `fprintf` takes a stream as its first argument. Afterward, it takes the message along with any amount of format strings, just like `printf`.", "return_value": "`fprintf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h", "fun_name": "fread", "signature": "size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fread` reads in data from a stream into an array in memory. Unlike other methods of input, `fread` reads in blocks of data of a user-specified size, making it possible to read in, for instance, entire strings instead of just characters. That being said, since specific functions exist in `stdio.h` for reading in different C data types, generally `fread` is best used only when reading in custom data types.", "return_value": "`fread` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "fseek", "description": "C streams are designed to be worked with linearly: files are written to and read from one unit at a time. As such, by design, you can't merely access, say, the middle of a file immediately (what you may call \"random access\"). Instead, you'd have to \"seek forward\" from the beginning of the file to the middle. This is where `fseek` is useful. `fseek` allows you to reposition the so-called \"file position indicator\" in a stream. This allows you, effectively, to skip around to different parts of files.", "return_value": "`fseek` returns 0 upon success and -1 upon error."}, {"library_name": "stdio.h", "fun_name": "fwrite", "signature": "size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fwrite` writes data to a stream from an address in memory. Unlike other methods of output, `fwrite` writes blocks of data of a user-specified size, making it possible to write, for instance, entire `struct` blocks at once instead of each piece of a `struct` separately.", "return_value": "`fwrite` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "printf", "signature": "int printf(const char *restrict format, ...);", "description": "`printf` is, in CS50, the most common way of outputting messages to the user in C. You can use it to print most anything, from characters to strings, integers to double-precision floating point numbers, and pretty much everything in between. `printf` also allows you to add some limited formatting to the output; for example, you can print `float` values to any number of decimal places.", "return_value": "`printf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h"}, {"library_name": "stdlib.h", "fun_name": "atof", "signature": "double atof(const char *str);", "description": "`atof` takes a string as input and converts it to a `float`. Although the `cs50.h` header file contains `get_float` to get user input directly as a `float`, if you use other methods of taking user input (e.g. command line arguments), you'll likely find that the input comes as a string (`char *`), not a `float`. `atof` comes in handy in instances such as that!", "return_value": "`atof` returns a `double`, representing the converted number. `atof` converts all of the string that it can: for instance, `1.2` would be converted to the `double` `1.2`, `2.8by` would become `2.8`, and `cs50` would just be converted to `0.0`."}, {"library_name": "stdlib.h", "fun_name": "atoi", "signature": "int atoi(const char *str);", "description": "`atof` takes a string as input and converts it to an `int`. Although the `cs50.h` header file contains `get_int` to get user input directly as a `int`, if you use other methods of taking user input (e.g. command line arguments), you'll likely find that the input comes as a string (`char *`), not a `int`. `atoi` comes in handy in instances such as that!", "return_value": "`atoi` returns an `int`, representing the converted number. `atoi` converts all of the string that it can: for instance, `32` would be converted to the `int` `32`, `-28t` would become `-28`, and `cs50` would just be converted to `0`."}, {"library_name": "stdlib.h", "fun_name": "calloc", "signature": "void *calloc(size_t count, size_t size);", "description": "`calloc` is, like [`malloc`](malloc.html), a way of dynamically allocating a chunk of memory (on the heap). Whereas `malloc` will simply allocate memory and return a pointer to it without further modification, `calloc` initializes all bytes of allocated memory to `0`.", "return_value": "Upon success, `calloc` will return a pointer to the allocated (and zeroed-out) memory. Otherwise, it will return a `NULL` pointer."}, {"library_name": "stdlib.h", "fun_name": "exit", "signature": "void exit(int status);", "description": "`exit` exits the program in a standard fashion; that is, all appropriate functions which should be called on exit are called, [`stdio`](../stdio/stdio.html) streams flushed and closed, and temporary files deleted. `exit` takes one integer argument: the exit code to return to the program's parent process (in most cases, akin to the return value of `main`). Although any `int` can be used in principle, the C standard specifies two macros for failure and success:", "return_value": "`exit` does not return a value."}, {"library_name": "stdlib.h", "fun_name": "free", "signature": "void free(void *ptr);", "description": "Whenever memory is allocated (via `malloc`, `calloc`, `realloc`, and the like), it will remain allocated until `free` is called on it. Allocating memory without `free`ing it is a bad practice which results in memory leaks--memory which the OS reserves to your program but is never used. This results in that memory, which could be used for other processes, being essentially wasted. In general, each call to an allocation function should be paired with a call to `free`.", "return_value": "`free` does not return any value."}, {"library_name": "stdlib.h", "fun_name": "malloc", "signature": "void *malloc(size_t size);", "description": "`malloc` is used to allocate a block of `size` bytes of memory on the heap. Note that the memory is not initialized in any way; be careful trying to access `malloc`'d memory without initializing its contents.", "return_value": "`malloc` returns a pointer to the allocated memory on success. If `malloc` fails, however, it will return a `NULL` pointer."}, {"library_name": "stdlib.h", "fun_name": "rand", "signature": "int rand(void);", "description": "`rand` computes pseudorandom numbers in the range of 0 and `RAND_MAX` (a value specified in `stdlib`). `rand` requires a seed; it defaults to 1, but the seed can be specified with [`srand`](srand.html).", "return_value": "`rand` returns the calculated pseudorandom `int`."}, {"library_name": "stdlib.h", "fun_name": "realloc", "signature": "void *realloc(void *ptr, size_t size);", "description": "`realloc` is used to resize a block of memory previously dynamically allocated (i.e., either by [`malloc`](malloc.html) or [`calloc`](calloc.html)). Its first argument, `ptr`, is a pointer to the block which should be resized. Its second argument, `size`, is the new size the block should be resized to.", "return_value": "Upon success, `realloc` returns a pointer to the block of resized memory (which may or may not be the same as `ptr`, depending on whether the block was expanded in-place or not). If it fails, a `NULL` pointer is returned."}, {"library_name": "stdlib.h", "fun_name": "srand", "signature": "void srand(unsigned int seed);", "description": "`srand` sets the provided `seed` parameter to be the new seed for [`rand`](rand.html). Oftentimes, `srand` is used in conjunction with [`time`](../time/time.html) in order to constantly refresh the seed it sets.", "return_value": "`srand` does not return a value."}, {"library_name": "stdlib.h"},{"library_name": "cs50.h", "fun_name": "get_char", "signature": "char get_char(string prompt);", "description": "`get_char` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_char` returns the `char` read on success; if the user input is not a `char`, the user is prompted to retry (until a `char` is inputted or the user cancels). If the line cannot be read at all, `CHAR_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_double", "signature": "double get_double(string prompt);", "description": "`get_double` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note that a `double` is, like `float`, a floating-point real number. However, the `double` type is twice as big as the `float` type, allowing it to be more precise. Generally speaking, `double` is preferable to `float` on modern computers, where memory is generally not sparse.", "return_value": "`get_double` returns the `double` read on success; if the user input is not readable as a `double`, the user is prompted to retry (until a `double` is inputted or the user cancels). If the line cannot be read at all, `DBL_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_float", "signature": "float get_float(string prompt);", "description": "`get_float` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_float` returns the `float` read on success; if the user input is not readable as a `float`, the user is prompted to retry (until a `float` is inputted or the user cancels). If the line cannot be read at all, `FLT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_int", "signature": "int get_int(string prompt);", "description": "`get_int` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_int` returns the `int` read on success; if the user input is not an `int`, the user is prompted to retry (until an `int` is inputted or the user cancels). If the line cannot be read at all, `INT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_long_long` take `long long` input from the user", "signature": "long long get_long_long(string prompt);", "description": "`get_long_long` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note: `long long` is the same type as `long long int`: the `int` at the end is optional. A `long long` is still an integer, but the `long long` type can store larger numbers than just an `int`.", "return_value": "`get_long_long` returns the `long long` read on success; if the user input is not a `long long`, the user is prompted to retry (until a `long long` is inputted or the user cancels). If the line cannot be read at all, `LLONG_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_string", "signature": "string get_string(string prompt);", "description": "`get_string` prints a prompt to the user and reads from `stdin`.", "return_value": "`get_string` returns the `string` read on success; if the user input is not readable as a `string`, the user is prompted to retry (until a `string` is inputted or the user cancels). If the line cannot be read at all, `NULL` is returned, representing an error."}, {"library_name": "ctype.h"}, {"library_name": "ctype.h", "fun_name": "isalnum", "signature": "int isalnum(int c);", "description": "`isalnum` takes a `char` as input and computes whether the character is alphanumeric.", "return_value": "`isalnum` returns a nonzero integer if it is either numeric or alphabetic (e.g. '1' or 'D') and zero if it is neither (e.g. '['). Note that C treats 0 as false and 1 as true; as such, `isalnum` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isalpha", "signature": "int isalpha(int c);", "description": "`isalpha` takes a character as input and computes whether the character is alphabetic.", "return_value": "`isalpha` returns a nonzero integer if it is alphabetic (e.g. 'C' or 'S') and zero if it is neither (e.g. '>' or '4'). Note that C treats 0 as false and 1 as true; as such, `isalpha` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isblank", "signature": "int isblank(int c);", "description": "`isblank` takes a character as input and calculates whether it is a blank character (space, tab).", "return_value": "`isblank` returns a nonzero integer if it is blank (e.g. ' ' or '  ', that is, space or tab) and zero if it is neither (e.g. 'y' or '}'). Note that C treats 0 as false and 1 as true; as such, `isblank` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isdigit", "signature": "int isdigit(int c);", "description": "`isdigit` takes a character as input and calculates whether it is a digit. N.B.: Since `isdigit` only covers decimal digits, don't use it for hexadecimal digits, such as `A` or `F`!", "return_value": "`isdigit` returns a nonzero integer if it is a decimal digit and 0 if it is not. Note that C treats 0 as false and 1 as true; as such, `isdigit` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "tolower", "signature": "int tolower(int c);", "description": "`tolower` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`tolower` returns the lower case `char` corresponding to the input. However, if the input is not an upper case `char`, the input is simply returned as-is; e.g., `tolower` of `]` would return `]` This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "ctype.h", "fun_name": "toupper", "signature": "int toupper(int c);", "description": "`toupper` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`toupper` returns the corresponding upper case `char`. However, if the input is not an lower case `char`, the input is simply returned as-is; e.g., `toupper` of `~` would return `~`. This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "stdio.h", "fun_name": "fclose", "signature": "int fclose(FILE *stream);", "description": "`fclose` is sort of the converse of [`fopen`](fopen.html). After you're done working with a file, `fclose` should be called on the associated stream to disconnect it from the file such that your file and its contents are saved safely. `fclose` takes only one parameter, a stream (of type `FILE *`). Generally, you should call `fclose` once for every call you make to `fopen`. Note too that once `fclose` is called on a stream, the stream now points to a garbage value; be careful about using streams which have already had `fclose` called on them.", "return_value": "`fclose` returns 0 on success. If an error of some sort occurs, `EOF` is returned."}, {"library_name": "stdio.h", "fun_name": "feof", "signature": "int feof(FILE *stream);", "description": "One part of the `FILE` type is the `EOF` flag. When a stream is positioned at the end of its associated file, this flag is set. As programmers, this is useful to know when we've reached the end of a file. `feof` takes only one parameter, a stream (of type `FILE *`) which is to be tested. `feof` allows testing whether the stream is positioned at its end without, say, attempting to read a character.", "return_value": "`feof` returns a non-zero `int` if `stream` is at `EOF`, otherwise 0."}, {"library_name": "stdio.h", "fun_name": "fopen", "signature": "FILE *fopen(const char *restrict filename, const char *restrict mode);", "description": "File I/O in C, just like other input and output, is done via streams. If you wish to write to and/or read from a file on the computer, you'll need to create a stream for that file: that's where `fopen` comes in. After the stream is opened, it can be interacted with (using other functions in `stdio`) as any other stream would be.", "return_value": "Upon success, `fopen` returns the stream associated with the provided `filename`. Otherwise, `NULL` is returned."}, {"library_name": "stdio.h", "fun_name": "fprintf", "signature": "int fprintf(FILE *restrict stream, const char *restrict format, ...);", "description": "`fprintf` is like `printf`, except it prints to a caller-specified stream instead of strictly `stdout`. In most cases for CS50, `fprintf` is used to print error messages to `stderr`. `fprintf` takes a stream as its first argument. Afterward, it takes the message along with any amount of format strings, just like `printf`.", "return_value": "`fprintf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h", "fun_name": "fread", "signature": "size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fread` reads in data from a stream into an array in memory. Unlike other methods of input, `fread` reads in blocks of data of a user-specified size, making it possible to read in, for instance, entire strings instead of just characters. That being said, since specific functions exist in `stdio.h` for reading in different C data types, generally `fread` is best used only when reading in custom data types.", "return_value": "`fread` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "fseek", "description": "C streams are designed to be worked with linearly: files are written to and read from one unit at a time. As such, by design, you can't merely access, say, the middle of a file immediately (what you may call \"random access\"). Instead, you'd have to \"seek forward\" from the beginning of the file to the middle. This is where `fseek` is useful. `fseek` allows you to reposition the so-called \"file position indicator\" in a stream. This allows you, effectively, to skip around to different parts of files.", "return_value": "`fseek` returns 0 upon success and -1 upon error."}, {"library_name": "stdio.h", "fun_name": "fwrite", "signature": "size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fwrite` writes data to a stream from an address in memory. Unlike other methods of output, `fwrite` writes blocks of data of a user-specified size, making it possible to write, for instance, entire `struct` blocks at once instead of each piece of a `struct` separately.", "return_value": "`fwrite` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "printf", "signature": "int printf(const char *restrict format, ...);", "description": "`printf` is, in CS50, the most common way of outputting messages to the user in C. You can use it to print most anything, from characters to strings, integers to double-precision floating point numbers, and pretty much everything in between. `printf` also allows you to add some limited formatting to the output; for example, you can print `float` values to any number of decimal places.", "return_value": "`printf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h"}, {"library_name": "stdlib.h", "fun_name": "atof", "signature": "double atof(const char *str);", "description": "`atof` takes a string as input and converts it to a `float`. Although the `cs50.h` header file contains `get_float` to get user input directly as a `float`, if you use other methods of taking user input (e.g. command line arguments), you'll likely find that the input comes as a string (`char *`), not a `float`. `atof` comes in handy in instances such as that!", "return_value": "`atof` returns a `double`, representing the converted number. `atof` converts all of the string that it can: for instance, `1.2` would be converted to the `double` `1.2`, `2.8by` would become `2.8`, and `cs50` would just be converted to `0.0`."}, {"library_name": "stdlib.h", "fun_name": "atoi", "signature": "int atoi(const char *str);", "description": "`atof` takes a string as input and converts it to an `int`. Although the `cs50.h` header file contains `get_int` to get user input directly as a `int`, if you use other methods of taking user input (e.g. command line arguments), you'll likely find that the input comes as a string (`char *`), not a `int`. `atoi` comes in handy in instances such as that!", "return_value": "`atoi` returns an `int`, representing the converted number. `atoi` converts all of the string that it can: for instance, `32` would be converted to the `int` `32`, `-28t` would become `-28`, and `cs50` would just be converted to `0`."}, {"library_name": "stdlib.h", "fun_name": "calloc", "signature": "void *calloc(size_t count, size_t size);", "description": "`calloc` is, like [`malloc`](malloc.html), a way of dynamically allocating a chunk of memory (on the heap). Whereas `malloc` will simply allocate memory and return a pointer to it without further modification, `calloc` initializes all bytes of allocated memory to `0`.", "return_value": "Upon success, `calloc` will return a pointer to the allocated (and zeroed-out) memory. Otherwise, it will return a `NULL` pointer."}, {"library_name": "stdlib.h", "fun_name": "exit", "signature": "void exit(int status);", "description": "`exit` exits the program in a standard fashion; that is, all appropriate functions which should be called on exit are called, [`stdio`](../stdio/stdio.html) streams flushed and closed, and temporary files deleted. `exit` takes one integer argument: the exit code to return to the program's parent process (in most cases, akin to the return value of `main`). Although any `int` can be used in principle, the C standard specifies two macros for failure and success:", "return_value": "`exit` does not return a value."}, {"library_name": "stdlib.h", "fun_name": "free", "signature": "void free(void *ptr);", "description": "Whenever memory is allocated (via `malloc`, `calloc`, `realloc`, and the like), it will remain allocated until `free` is called on it. Allocating memory without `free`ing it is a bad practice which results in memory leaks--memory which the OS reserves to your program but is never used. This results in that memory, which could be used for other processes, being essentially wasted. In general, each call to an allocation function should be paired with a call to `free`.", "return_value": "`free` does not return any value."}, {"library_name": "stdlib.h", "fun_name": "malloc", "signature": "void *malloc(size_t size);", "description": "`malloc` is used to allocate a block of `size` bytes of memory on the heap. Note that the memory is not initialized in any way; be careful trying to access `malloc`'d memory without initializing its contents.", "return_value": "`malloc` returns a pointer to the allocated memory on success. If `malloc` fails, however, it will return a `NULL` pointer."}, {"library_name": "stdlib.h", "fun_name": "rand", "signature": "int rand(void);", "description": "`rand` computes pseudorandom numbers in the range of 0 and `RAND_MAX` (a value specified in `stdlib`). `rand` requires a seed; it defaults to 1, but the seed can be specified with [`srand`](srand.html).", "return_value": "`rand` returns the calculated pseudorandom `int`."}, {"library_name": "stdlib.h", "fun_name": "realloc", "signature": "void *realloc(void *ptr, size_t size);", "description": "`realloc` is used to resize a block of memory previously dynamically allocated (i.e., either by [`malloc`](malloc.html) or [`calloc`](calloc.html)). Its first argument, `ptr`, is a pointer to the block which should be resized. Its second argument, `size`, is the new size the block should be resized to.", "return_value": "Upon success, `realloc` returns a pointer to the block of resized memory (which may or may not be the same as `ptr`, depending on whether the block was expanded in-place or not). If it fails, a `NULL` pointer is returned."}, {"library_name": "stdlib.h", "fun_name": "srand", "signature": "void srand(unsigned int seed);", "description": "`srand` sets the provided `seed` parameter to be the new seed for [`rand`](rand.html). Oftentimes, `srand` is used in conjunction with [`time`](../time/time.html) in order to constantly refresh the seed it sets.", "return_value": "`srand` does not return a value."}, {"library_name": "stdlib.h"}, {"library_name": "string.h", "fun_name": "strcat", "signature": "char *strcat(char *restrict s1, const char *restrict s2);", "description": "`strcat` takes two `char *` as input and concatenates the two (i.e., appends one to the end of the other).", "return_value": "`strcat` returns a pointer to the result of appending the second string to the first, i.e., `s1`."}, {"library_name": "string.h", "fun_name": "strcmp", "signature": "int strcmp(const char *s1, const char *s2);", "description": "`strcmp` takes two `char *` as input and calculates whether the two strings are equal or, if not, which comes alphabetically first.", "return_value": "`strcmp` returns an `int` reflecting the difference between `s1` and `s2`: 0 means the strings are equal, greater than 0 means `s2` is alphabetically before `s1`, and less than 0 means `s1` is alphabetically before `s2`."}, {"library_name": "string.h", "fun_name": "strcpy", "signature": "char *strcat(char *dst, const char *src);", "description": "`strcpy` copies the contents of `src` into `dst`. This includes the `NUL` terminator (`\\0`).", "return_value": "`strcpy` returns `dst`."}, {"library_name": "string.h"}, {"library_name": "string.h", "fun_name": "strlen", "signature": "size_t strlen(const char *s);", "description": "`strlen` calculates the length of string `s` (not including the null terminator).", "return_value": "`strlen` returns the number of characters between `s` and the null terminator."}, {"library_name": "string.h", "fun_name": "strstr", "signature": "char *strstr(const char *haystack, const char *needle);", "description": "`strstr` locates the first occurrence of string `needle` within string `haystack`.", "return_value": "`strstr` returns the pointer to the first occurrence of `needle` within `haystack`. If `needle` cannot be found in `haystack`, `NULL` is returned."},{"library_name": "cs50.h", "fun_name": "get_char", "signature": "char get_char(string prompt);", "description": "`get_char` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_char` returns the `char` read on success; if the user input is not a `char`, the user is prompted to retry (until a `char` is inputted or the user cancels). If the line cannot be read at all, `CHAR_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_double", "signature": "double get_double(string prompt);", "description": "`get_double` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note that a `double` is, like `float`, a floating-point real number. However, the `double` type is twice as big as the `float` type, allowing it to be more precise. Generally speaking, `double` is preferable to `float` on modern computers, where memory is generally not sparse.", "return_value": "`get_double` returns the `double` read on success; if the user input is not readable as a `double`, the user is prompted to retry (until a `double` is inputted or the user cancels). If the line cannot be read at all, `DBL_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_float", "signature": "float get_float(string prompt);", "description": "`get_float` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_float` returns the `float` read on success; if the user input is not readable as a `float`, the user is prompted to retry (until a `float` is inputted or the user cancels). If the line cannot be read at all, `FLT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_int", "signature": "int get_int(string prompt);", "description": "`get_int` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored.", "return_value": "`get_int` returns the `int` read on success; if the user input is not an `int`, the user is prompted to retry (until an `int` is inputted or the user cancels). If the line cannot be read at all, `INT_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_long_long` take `long long` input from the user", "signature": "long long get_long_long(string prompt);", "description": "`get_long_long` prints a prompt to the user and reads from `stdin`. Any whitespace in the input is ignored. Note: `long long` is the same type as `long long int`: the `int` at the end is optional. A `long long` is still an integer, but the `long long` type can store larger numbers than just an `int`.", "return_value": "`get_long_long` returns the `long long` read on success; if the user input is not a `long long`, the user is prompted to retry (until a `long long` is inputted or the user cancels). If the line cannot be read at all, `LLONG_MAX` is returned, representing an error."}, {"library_name": "cs50.h", "fun_name": "get_string", "signature": "string get_string(string prompt);", "description": "`get_string` prints a prompt to the user and reads from `stdin`.", "return_value": "`get_string` returns the `string` read on success; if the user input is not readable as a `string`, the user is prompted to retry (until a `string` is inputted or the user cancels). If the line cannot be read at all, `NULL` is returned, representing an error."}, {"library_name": "ctype.h"}, {"library_name": "ctype.h", "fun_name": "isalnum", "signature": "int isalnum(int c);", "description": "`isalnum` takes a `char` as input and computes whether the character is alphanumeric.", "return_value": "`isalnum` returns a nonzero integer if it is either numeric or alphabetic (e.g. '1' or 'D') and zero if it is neither (e.g. '['). Note that C treats 0 as false and 1 as true; as such, `isalnum` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isalpha", "signature": "int isalpha(int c);", "description": "`isalpha` takes a character as input and computes whether the character is alphabetic.", "return_value": "`isalpha` returns a nonzero integer if it is alphabetic (e.g. 'C' or 'S') and zero if it is neither (e.g. '>' or '4'). Note that C treats 0 as false and 1 as true; as such, `isalpha` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isblank", "signature": "int isblank(int c);", "description": "`isblank` takes a character as input and calculates whether it is a blank character (space, tab).", "return_value": "`isblank` returns a nonzero integer if it is blank (e.g. ' ' or '  ', that is, space or tab) and zero if it is neither (e.g. 'y' or '}'). Note that C treats 0 as false and 1 as true; as such, `isblank` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "isdigit", "signature": "int isdigit(int c);", "description": "`isdigit` takes a character as input and calculates whether it is a digit. N.B.: Since `isdigit` only covers decimal digits, don't use it for hexadecimal digits, such as `A` or `F`!", "return_value": "`isdigit` returns a nonzero integer if it is a decimal digit and 0 if it is not. Note that C treats 0 as false and 1 as true; as such, `isdigit` is easily used in conditional statements."}, {"library_name": "ctype.h", "fun_name": "tolower", "signature": "int tolower(int c);", "description": "`tolower` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`tolower` returns the lower case `char` corresponding to the input. However, if the input is not an upper case `char`, the input is simply returned as-is; e.g., `tolower` of `]` would return `]` This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "ctype.h", "fun_name": "toupper", "signature": "int toupper(int c);", "description": "`toupper` takes a `char` as input. Beware that behavior is undefined outside of the range of `unsigned char` (0 - 127)!", "return_value": "`toupper` returns the corresponding upper case `char`. However, if the input is not an lower case `char`, the input is simply returned as-is; e.g., `toupper` of `~` would return `~`. This does not necessarily hold true outside the range of `unsigned char`."}, {"library_name": "stdio.h", "fun_name": "fclose", "signature": "int fclose(FILE *stream);", "description": "`fclose` is sort of the converse of [`fopen`](fopen.html). After you're done working with a file, `fclose` should be called on the associated stream to disconnect it from the file such that your file and its contents are saved safely. `fclose` takes only one parameter, a stream (of type `FILE *`). Generally, you should call `fclose` once for every call you make to `fopen`. Note too that once `fclose` is called on a stream, the stream now points to a garbage value; be careful about using streams which have already had `fclose` called on them.", "return_value": "`fclose` returns 0 on success. If an error of some sort occurs, `EOF` is returned."}, {"library_name": "stdio.h", "fun_name": "feof", "signature": "int feof(FILE *stream);", "description": "One part of the `FILE` type is the `EOF` flag. When a stream is positioned at the end of its associated file, this flag is set. As programmers, this is useful to know when we've reached the end of a file. `feof` takes only one parameter, a stream (of type `FILE *`) which is to be tested. `feof` allows testing whether the stream is positioned at its end without, say, attempting to read a character.", "return_value": "`feof` returns a non-zero `int` if `stream` is at `EOF`, otherwise 0."}, {"library_name": "stdio.h", "fun_name": "fopen", "signature": "FILE *fopen(const char *restrict filename, const char *restrict mode);", "description": "File I/O in C, just like other input and output, is done via streams. If you wish to write to and/or read from a file on the computer, you'll need to create a stream for that file: that's where `fopen` comes in. After the stream is opened, it can be interacted with (using other functions in `stdio`) as any other stream would be.", "return_value": "Upon success, `fopen` returns the stream associated with the provided `filename`. Otherwise, `NULL` is returned."}, {"library_name": "stdio.h", "fun_name": "fprintf", "signature": "int fprintf(FILE *restrict stream, const char *restrict format, ...);", "description": "`fprintf` is like `printf`, except it prints to a caller-specified stream instead of strictly `stdout`. In most cases for CS50, `fprintf` is used to print error messages to `stderr`. `fprintf` takes a stream as its first argument. Afterward, it takes the message along with any amount of format strings, just like `printf`.", "return_value": "`fprintf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h", "fun_name": "fread", "signature": "size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fread` reads in data from a stream into an array in memory. Unlike other methods of input, `fread` reads in blocks of data of a user-specified size, making it possible to read in, for instance, entire strings instead of just characters. That being said, since specific functions exist in `stdio.h` for reading in different C data types, generally `fread` is best used only when reading in custom data types.", "return_value": "`fread` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "fseek", "description": "C streams are designed to be worked with linearly: files are written to and read from one unit at a time. As such, by design, you can't merely access, say, the middle of a file immediately (what you may call \"random access\"). Instead, you'd have to \"seek forward\" from the beginning of the file to the middle. This is where `fseek` is useful. `fseek` allows you to reposition the so-called \"file position indicator\" in a stream. This allows you, effectively, to skip around to different parts of files.", "return_value": "`fseek` returns 0 upon success and -1 upon error."}, {"library_name": "stdio.h", "fun_name": "fwrite", "signature": "size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);", "description": "`fwrite` writes data to a stream from an address in memory. Unlike other methods of output, `fwrite` writes blocks of data of a user-specified size, making it possible to write, for instance, entire `struct` blocks at once instead of each piece of a `struct` separately.", "return_value": "`fwrite` returns, as a `size_t`, the number of objects written. If an error occurs or `EOF` is reached, of course, it will return early."}, {"library_name": "stdio.h", "fun_name": "printf", "signature": "int printf(const char *restrict format, ...);", "description": "`printf` is, in CS50, the most common way of outputting messages to the user in C. You can use it to print most anything, from characters to strings, integers to double-precision floating point numbers, and pretty much everything in between. `printf` also allows you to add some limited formatting to the output; for example, you can print `float` values to any number of decimal places.", "return_value": "`printf` returns, as an `int`, the number of characters written."}, {"library_name": "stdio.h"}, {"library_name": "stdlib.h", "fun_name": "atof", "signature": "double atof(const char *str);", "description": "`atof` takes a string as input and converts it to a `float`. Although the `cs50.h` header file contains `get_float` to get user input directly as a `float`, if you use other methods of taking user input (e.g. command line arguments), you'll likely find that the input comes as a string (`char *`), not a `float`. `atof` comes in handy in instances such as that!", "return_value": "`atof` returns a `double`, representing the converted number. `atof` converts all of the string that it can: for instance, `1.2` would be converted to the `double` `1.2`, `2.8by` would become `2.8`, and `cs50` would just be converted to `0.0`."}, {"library_name": "stdlib.h", "fun_name": "atoi", "signature": "int atoi(const char *str);", "description": "`atof` takes a string as input and converts it to an `int`. Although the `cs50.h` header file contains `get_int` to get user input directly as a `int`, if you use other methods of taking user input (e.g. command line arguments), you'll likely find that the input comes as a string (`char *`), not a `int`. `atoi` comes in handy in instances such as that!", "return_value": "`atoi` returns an `int`, representing the converted number. `atoi` converts all of the string that it can: for instance, `32` would be converted to the `int` `32`, `-28t` would become `-28`, and `cs50` would just be converted to `0`."}, {"library_name": "stdlib.h", "fun_name": "calloc", "signature": "void *calloc(size_t count, size_t size);", "description": "`calloc` is, like [`malloc`](malloc.html), a way of dynamically allocating a chunk of memory (on the heap). Whereas `malloc` will simply allocate memory and return a pointer to it without further modification, `calloc` initializes all bytes of allocated memory to `0`.", "return_value": "Upon success, `calloc` will return a pointer to the allocated (and zeroed-out) memory. Otherwise, it will return a `NULL` pointer."}, {"library_name": "stdlib.h", "fun_name": "exit", "signature": "void exit(int status);", "description": "`exit` exits the program in a standard fashion; that is, all appropriate functions which should be called on exit are called, [`stdio`](../stdio/stdio.html) streams flushed and closed, and temporary files deleted. `exit` takes one integer argument: the exit code to return to the program's parent process (in most cases, akin to the return value of `main`). Although any `int` can be used in principle, the C standard specifies two macros for failure and success:", "return_value": "`exit` does not return a value."}, {"library_name": "stdlib.h", "fun_name": "free", "signature": "void free(void *ptr);", "description": "Whenever memory is allocated (via `malloc`, `calloc`, `realloc`, and the like), it will remain allocated until `free` is called on it. Allocating memory without `free`ing it is a bad practice which results in memory leaks--memory which the OS reserves to your program but is never used. This results in that memory, which could be used for other processes, being essentially wasted. In general, each call to an allocation function should be paired with a call to `free`.", "return_value": "`free` does not return any value."}, {"library_name": "stdlib.h", "fun_name": "malloc", "signature": "void *malloc(size_t size);", "description": "`malloc` is used to allocate a block of `size` bytes of memory on the heap. Note that the memory is not initialized in any way; be careful trying to access `malloc`'d memory without initializing its contents.", "return_value": "`malloc` returns a pointer to the allocated memory on success. If `malloc` fails, however, it will return a `NULL` pointer."}, {"library_name": "stdlib.h", "fun_name": "rand", "signature": "int rand(void);", "description": "`rand` computes pseudorandom numbers in the range of 0 and `RAND_MAX` (a value specified in `stdlib`). `rand` requires a seed; it defaults to 1, but the seed can be specified with [`srand`](srand.html).", "return_value": "`rand` returns the calculated pseudorandom `int`."}, {"library_name": "stdlib.h", "fun_name": "realloc", "signature": "void *realloc(void *ptr, size_t size);", "description": "`realloc` is used to resize a block of memory previously dynamically allocated (i.e., either by [`malloc`](malloc.html) or [`calloc`](calloc.html)). Its first argument, `ptr`, is a pointer to the block which should be resized. Its second argument, `size`, is the new size the block should be resized to.", "return_value": "Upon success, `realloc` returns a pointer to the block of resized memory (which may or may not be the same as `ptr`, depending on whether the block was expanded in-place or not). If it fails, a `NULL` pointer is returned."}, {"library_name": "stdlib.h", "fun_name": "srand", "signature": "void srand(unsigned int seed);", "description": "`srand` sets the provided `seed` parameter to be the new seed for [`rand`](rand.html). Oftentimes, `srand` is used in conjunction with [`time`](../time/time.html) in order to constantly refresh the seed it sets.", "return_value": "`srand` does not return a value."}, {"library_name": "stdlib.h"}, {"library_name": "string.h", "fun_name": "strcat", "signature": "char *strcat(char *restrict s1, const char *restrict s2);", "description": "`strcat` takes two `char *` as input and concatenates the two (i.e., appends one to the end of the other).", "return_value": "`strcat` returns a pointer to the result of appending the second string to the first, i.e., `s1`."}, {"library_name": "string.h", "fun_name": "strcmp", "signature": "int strcmp(const char *s1, const char *s2);", "description": "`strcmp` takes two `char *` as input and calculates whether the two strings are equal or, if not, which comes alphabetically first.", "return_value": "`strcmp` returns an `int` reflecting the difference between `s1` and `s2`: 0 means the strings are equal, greater than 0 means `s2` is alphabetically before `s1`, and less than 0 means `s1` is alphabetically before `s2`."}, {"library_name": "string.h", "fun_name": "strcpy", "signature": "char *strcat(char *dst, const char *src);", "description": "`strcpy` copies the contents of `src` into `dst`. This includes the `NUL` terminator (`\\0`).", "return_value": "`strcpy` returns `dst`."}, {"library_name": "string.h"}, {"library_name": "string.h", "fun_name": "strlen", "signature": "size_t strlen(const char *s);", "description": "`strlen` calculates the length of string `s` (not including the null terminator).", "return_value": "`strlen` returns the number of characters between `s` and the null terminator."}, {"library_name": "string.h", "fun_name": "strstr", "signature": "char *strstr(const char *haystack, const char *needle);", "description": "`strstr` locates the first occurrence of string `needle` within string `haystack`.", "return_value": "`strstr` returns the pointer to the first occurrence of `needle` within `haystack`. If `needle` cannot be found in `haystack`, `NULL` is returned."}, {"library_name": "time.h", "fun_name": "time", "signature": "time_t time(time_t *tloc);", "description": "`time` calculates the current time, expressed in the number of seconds that have passed since January 1, 1970, UTC (commonly referred to as the \"Unix Epoch\").", "return_value": "`time` returns the time value it calculates. This value is also stored in `tloc` if possible."}]
